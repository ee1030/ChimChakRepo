객체란? 변수들과 그와 관련된 메서드들이 모여서 이룬 하나의 꾸러미

클래스란? C의 구조체에서 확정된 변수, 객체, 함수를 포함한 하나의 틀

///////////////////////////////////////////////////////////////////////////////////////////////
일반적인 C언어로 구현한 코드

#include <stdio.h>

//제작자의 코드

typedef struct USERDATA
{
	int nAge;
	char szName[32];
}USERDATA;

//사용자의 코드

int main(void)
{
	USERDATA user = { 20, "철수" };
	printf("%d, %s\n", user.nAge, user.szName);

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////

사용자의 입장에서 굉장히 불친절한 코드임
1. 사용자는 제작자가 만든 자료구조의 멤버 및 구성을 알아야하고
2. 자료구조에 담긴 정보를 출력하려면 사용자 스스로 직접 멤버에 접근해야 하고 적절한 출력방법도 선택해야함
3. 제작자가 자료구조를 변경한다면 사용자는 제작자의 코드와 관련된 자신의 코드를 몽땅 수정해야함

///////////////////////////////////////////////////////////////////////////////////////////////

똑같은 C언어지만 PrintData라는 함수를 만들어 제공하였을 경우

#include <stdio.h>

//제작자의 코드

typedef struct USERDATA
{
	int nAge;
	char szName[32];
}USERDATA;

void PrintData(USERDATA *pUser)
{
	printf("%d. %s\n", pUser->nAge, pUser->szName);
}
//사용자의 코드

int main(void)
{
	USERDATA user = { 20, "철수" };
	// printf("%d, %s\n", user.nAge, user.szName);  // 1단계
	PrintData(&user);								// 2단계

	return 0;
}

이런경우 만일 제작자가 자료구조를 변경하더라도 사용자는 코드를 수정할 필요가 없다.
이러한 방식을 객체지향에서는 인터페이스하고 부르는데 매우 중요한 개념이다.
PrintData같은 함수를 '인터페이스 함수'라고 부른다.

///////////////////////////////////////////////////////////////////////////////////////////////

구조체 안에 함수를 집어넣어버리기

#include <stdio.h>

//제작자의 코드

typedef struct USERDATA
{
	int nAge;
	char szName[32];
	void(*Print)(struct USERDATA *);
}USERDATA;

void PrintData(USERDATA *pUser)
{
	printf("%d. %s\n", pUser->nAge, pUser->szName);
}
//사용자의 코드

int main(void)
{
	USERDATA user = { 20, "철수", PrintData};
	// printf("%d, %s\n", user.nAge, user.szName);  // 1단계
	//PrintData(&user);								// 2단계
	user.Print(&user);								// 3단계

	return 0;
}

C 문법 구조상 구조체에 함수를 넣을 수는 없지만 객체를 초기화할때 출력을 담당하는 함수의 주소를 기술하고
user.Print(&user)의 형태로 사용할수 있다.
다만 Print() 함수가 user의 멤버인데 user의 주소를 모르기때문에 어색해보인다. 

C++에서는 이런 상황을 없애기 위해 코드를 바꿔버린다. user.Print(&user)를 user.Print()로
여기서 중요한것은 user.Print() 코드에서 실제로는 &user가 여전히 존재한다는 것이다.
이것은 this 포인터를 배울때 이해하는데 큰 도움이 될것


///////////////////////////////////////////////////////////////////////////////////////////////

클래스 기본 문법

클래스는 정말 쉽게 생각하면 '함수를 포함할 수 있는 구조체'라고 정의할 수 있다.

클래스를 선언하는 방법

class 이름
{
접근제어지시자;
	멤버변수 선언;
	멤버함수선언및정의;
};

구조체랑 다른점? '접근 제어 지시자'라는 것이 등장했다는 것과 함수를 멤버로 포함할 수 있다는 것.

///////////////////////////////////////////////////////////////////////////////////////////////
C++ 클래스를 사용하였을때

#include "stdafx.h"
#include <iostream>
#include <cstdio>
using namespace std;

//제작자의 코드
class USERDATA
{
public: 
	//멤버변수 선언
	int nAge;
	char szName[32];

	//멤버 함수 선언 및 정의
	void Print(void)
	{
		//nAge와 szName은 Print()함수의 지역변수가 아니다!
		printf("%d, %s\n", nAge, szName);
	}
};

//사용자의 코드
int main()
{
	USERDATA user = { 10, "철수" };
	user.Print();

	return 0;
}

여기서 public은 접근 제어 지시자로써 public을 사용하면 기본적으로 구조체를 사용하는 것과 같은 개념
그렇기 때문에 사용자 코드에서, 혹은 -> 같은 멤버 접근 연산자를 이용해 구조체 내부 멤버에 접근 할 수 있다.
하지만 c++ 에서는 Public 외에 Protected, private 접근 제어 지시자를 이용해 접근을 차단할 수 있다.


void Print(void)부분은 USERDATA 클래스의 멤버 함수인 Print() 함수를 정의한것.
중요한것은 nAge변수와 szName 변수가 Print() 함수 내부에서 선언 된 지역변수가 아니라 Print()함수가 속한
클래스의 멤버 변수라는 사실이다. 

여기서 제일 C다운 부분은 USERDATA user = { 10, "철수" }; 부분인데 구조체 초기화 방법을 그대로 사용했을 뿐 아니라
멤버 변수 초기화라는 중요한 일을 사용자가 알아서 하도록 방치했다는 데에 문제가 있다.

생성자~~~~~~~~

생성자를 사용하는 함수의 가장 중요한 특징

"반환 자료형이 없다."
"호출하는 함수가 아니라 적절한 시기에 내부에서 자동으로 호출되는 함수"

///////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
public:
	//CTest 클래스의 '생성자 함수' 선언 및 정의
	CTest()
	{
		//인스턴스가 생성되면 멤버 데이터를 '자동으로' 초기화 한다.
		m_nData = 10;
	}

	//멤버 데이터 선언
	int m_nData;

	//멤버 함수 선언 및 정의
	void PrintData(void)
	{
		//멤버 데이터에 접근하고 값을 출력한다.
		cout << m_nData << endl;
	}
};

//사용자의 코드
int main()
{
	CTest t;  //생성자 호출
	t.PrintData();

	return 0;
}

CTest() 함수는 CTest 클래스의 생성자 함수이다. 이 함수는 사용자가 객체를 선언하면 자동으로 호출된다.
CTest t; 코드를 통해 CTest 클래스의 m_nData 멤버를 10으로 초기화함

///////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
public:
	//CTest 클래스의 '생성자 함수' 선언 및 정의
	CTest()
	{
		//인스턴스가 생성되면 멤버 데이터를 '자동으로' 초기화 한다.
		cout << "CTest() : 생성자 함수" << endl;
		m_nData = 10;
	}

	//멤버 데이터 선언
	int m_nData;

	//멤버 함수 선언 및 정의
	void PrintData(void)
	{
		//멤버 데이터에 접근하고 값을 출력한다.
		cout << m_nData << endl;
	}
};

//사용자의 코드
int main()
{
	cout << "main() 함수 시작" << endl;
	CTest t;  //생성자 호출
	t.PrintData();
	cout << "main() 함수 끝" << endl;

	return 0;
}

이번 코드에서는 생성자 함수가 어떻게 역할을 하는지 알아보기 쉽게 하기 위해서 출력 문구들을 넣었음

///////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
public:
	//CTest 클래스의 '생성자 함수' 선언 및 정의
	CTest()
	{
		//인스턴스가 생성되면 멤버 데이터를 '자동으로' 초기화 한다.
		m_nData = 10;
	}

	//멤버 데이터 선언
	int m_nData;

	//멤버 함수 선언, 정의는 분리함
	void PrintData(void);
};

//외부에 분리된 멤버 함수의 정의
void CTest::PrintData(void)
{
	//멤버 데이터에 접근하고 값을 출력한다.
	cout << m_nData << endl;
}
//사용자의 코드
int main()
{
	CTest t;  //생성자 호출
	t.PrintData();

	return 0;
}

이번코드는 멤버 함수를 클래스 안에서 선언만 하고 정의는 바깥에 따로 분리해서 해보았다. 똑같이 됨
마찬가지로 분리된 함수 정의의 m_nData 가 클래스의 멤버 변수라는 점이 중요함 모든 멤버함수는 기본적으로
지역, 멤버, 전역 변수 순으로 식별자를 검색한다.

///////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
public:
	//생성자 초기화 목록을 이용한 멤버 초기화
	CTest()
		:m_nData1(10), m_nData2(20)
	{}
	
	int m_nData1;
	int m_nData2;
	
	/*
	C++ 11분터는 위처럼 하는 대신에
	CTest() {}

	int m_nData1 = 10;
	int m_nData2 = 20;
	같은 형식으로 선언하면서 초기화 가능
	*/

	void PrintData(void)
	{
		//두개의 멤버 데이터에 접근하고 값을 출력
		cout << m_nData1 << endl;
		cout << m_nData2 << endl;
	}
};

//사용자의 코드
int main()
{
	CTest t;  //생성자 호출
	t.PrintData();

	return 0;
}

생성자 초기화 목록을 이용한 멤버 초기화를 한 코드 CTest() 함수 원형과 몸체 사이에 :(콜론)을 쓰고 멤버 변수(초기화값) 식으로
기슬한다. 초기화 하려는 멤버가 여러개라면 쉼표를 찍고 구분해주면 됨 멤버 변수가 참조가 형식이면 무조건
초기홤 목록을 이용해 초기화 해줘야 함

C++ 11 부터는 선언과 동시에 초기화도 가능하다.
///////////////////////////////////////////////////////////////////////////////////////////////

여기가지는 클래스의 멤버변수를 선언하고 초기화하는 방법들을 알아보았다. 

접근 제어 지시자

접근 제어 지시자는 구조체가 클래스로 탈바꿈 하도록 돕는 문법.
왜 쓰는가? 제작자 스스로 자신이 만든 클래스의 특정 요소에 사용자가 접근 할 수 없게 하기 위해
Why? 제작자의 의도와 다르게 사용자의 과실로 클래스가 망가질 수도 있기 때문

접근 제어 지시자의 종류

-------------------------------------------------------------------------------------------------------------------------------------
public : 멤버에 관한 모든 외부 접근 허용

protected : 멤버에 관한 모든 외부 접근 차단. 단, 상속 관계에 있는 파생 클래스에서의 접근은 허용

private : 외부 접근 뿐만 아니라 파생 클래스로부터의 접근까지 모두 차단. 클래스를 선언할때 별도로 접근 제어 지시자를 기술하
지 않으면 자동으로 private로 간주한다.
-------------------------------------------------------------------------------------------------------------------------------------

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CMyData
{
	// 기본 접근 제어 지시자는 'private'이다
	int m_nData;

public:
	int GetData(void) { return m_nData; }
	void setData(int nParam) { m_nData = nParam; }
};
//사용자의 코드
int main()
{
	CMyData data;
	data.setData(10);
	cout << data.GetData() << endl;
	return 0;
}

위의 코드에서는 m_nData에 대한 접근 제어 지시자가 private 이기 때문에 사용자 코드에서 멤버 접근 연사자를 통해 멤버
변수에 임의 접근 할 수 없다. 이 말은 곧 

data.m_nData = 10;
cout << data.m_nData << endl;

같은 코드가 동작할 수 없다는 뜻이다.

멤버 함수의 같은 경우 private 멤버에 접근하는 것이 자유롭다. 바꿔 말하면 접근 제어 지시자의 영향을 받지 않는다는 뜻
생성자도 접근 제어 지시자의 영향을 받는다.

무슨말이냐면 위의 클래스에 생성자 함수 CMyData() {} 를 추가하더라도 사용할 수 없다는 말임. private의 영향으로 멤버에
접근할 수 없기 떄문

생성자와 소멸자

생성자(Constructer)와 소멸자(Destructer)는 클래스 객체가 생성 및 소멸 될 때 자동으로 호출되는 함수이다.
이 두 함수의 가장 큰 특징은 함수임에도 반환형식이 없다는 것과 함수 이름이 클래스의 이름과 같다는 점.
다만 소멸자의 이름 앞에는 ~이 붙는다. 둘의 차이점은 생성자는 정의할 수 있지만 소멸자는 그럴 수 없다는것

클래스이름();
~클래스이름();

그리고 위처럼 매개변수가 하나도 없는 생성자를 '디폴트 생성자'라고 부른다. 디폴트 생성자의 특징은
클래스 제작자가 디폴트 생성자와 소멸자를 기술하지 않아도 컴파일러가 알아서 만들어 넣는다는 점이다.
단, 아무런 코드도 추가 되지는 않음 암튼 생성자와 소멸자가 없는 클래스는 음슴 무조건 잇음 잇다면 잇음 잇는거임 토달지마셈


///////////////////////////////////////////////////////////////////////////////////////////////

생성자와 소멸자

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
public:
	CTest()
	{
		cout << "CTest::CTest()" << endl;
	}

	~CTest()
	{
		cout << "~CTest::Ctest()" << endl;
	}
};

//사용자의 코드
int main()
{
	cout << "Begin" << endl;
	CTest a;
	cout << "End" << endl;

	return 0;
}

위 코드에서는 생성자와 소멸자가 언제 호출 되는지를 출력해준다. 비긴 다음으로 CTest 클래스의 인스턴스인 a를 선언
이 시점이 바로 객체가 생성되는 시점이라는 것, a가 main함수에 속한 지역변수라는 것이다. 지역변수는 특성상
선언된 블록 범위가 끝나면 자동으로 소멸한다. 따라서 main 함수의 실행이 끝나면 a는 소멸하는 것이다. 따라서 End까지
나와서 지역변수가 속한 블록이 모두 종료 되야 a가 자동으로 소멸되는 것이다. 그래서 End보다 소멸자 출력이 나중에 나오는것
헷갈리기 쉽다.

위의 코드에서 CTest a; 즉 인스턴스 선언을 main 함수 밖으로 빼내면 생성자 -> 비긴 -> 엔드 -> 소멸자 순으로 출력된다
이건 a가 지역 변수에서 전역 변수로 바뀌었기 때문인데 C++에서는 무조건 main함수가 가장먼저 호출되는 것이 아니라
전역 변수로 선언한 클래스의 생성자가 main 함수보다 먼저 호출된다. 시험 내기 개좋음 따흐흐흑

int main()
{
	cout << "Begin" << endl;
	CTest a;
	cout << "Before b" << endl;
	CTest b;
	cout << "End" << endl;

	return 0;
}

위와같이 코드를 수정했을 경우에도 main함수의 마지막 구문이 실행 되고 나서 내부에 지역변수들이 소멸된다는 것을 알 수 있다.

내용 정리

1. main() 함수가 호출되기 전에 생성자가 호출 될 수 있다.
2. 생성자는 다중 정의 할 수 있다.
3. 소멸자는 다중 정의 할 수 없다.
4. main() 함수가 끝난 후에 소멸자가 호출될 수 있다.
5. 생성자와 소멸자는 생략할 수 있으나 생략할 경우 컴파일러가 만들어 넣는다.

///////////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
	int m_nData;

public:
	//생성자의 매개변수로 전달된 값으로 멤버 변수를 초기화 한다.
	CTest(int nParam) : m_nData(nParam)
	{
		cout << "CTest::CTest()" << endl;
	}

	~CTest() // 생성할 때 매개변수로 받은 값을 출력한다.
	{
		cout << "~CTest::Ctest()" << m_nData << endl;
	}
};

//사용자의 코드
int main()
{
	cout << "Begin" << endl;
	CTest a(1);
	cout << "Before b" << endl;
	CTest b(2);
	cout << "End" << endl;

	return 0;
}

위의 코드와 같이 생성자의 매개변수로 받은 값으로 멤버 변수를 초기화했다 여기에 디폴트 생성자는 생략 하였으므로
CTest a;와 같은 코드는 오류가 난다능 

동적 객체의 생성과 소멸

클래스의 인스턴스는 선언해서 사용할 수 있다. 더불어 new 연산을 통해 동적으로 생성할 수도 있음
그리고 동적으로 생성된 객체는 delete 연산자로 삭제해야 한다. 이와같이 동적으로 객체 생성 및 소멸을 시도할 경우
코드에서 그 시점을 명확히 알 수 있음.

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CTest
{
	int m_nData;

public:
	//생성자의 매개변수로 전달된 값으로 멤버 변수를 초기화 한다.
	CTest()
	{
		cout << "CTest::CTest()" << endl;
	}

	~CTest() // 생성할 때 매개변수로 받은 값을 출력한다.
	{
		cout << "~CTest::Ctest()" << endl;
	}
};

//사용자의 코드
int main()
{
	cout << "Begin" << endl;

	//new 연산자를 이용해 동적으로 객체를 생성한다.
	CTest *pData = new CTest;
	cout << "Test" << endl;

	//delete 연산자를 이용해 객체를 삭제한다.
	delete pData;
	cout << "End" << endl;

	return 0;
}

위의 코드에서는 new와 delete 연산자를 이용해서 동적으로 객체를 생성하고 해제했다. 결과값은
비긴 -> 생성자 -> 테스트 -> 소멸자 -> 엔드 순으로 만약 동적으로 생성하지 않고 지역변수로 객체를 생성했다면
END 이후에 소멸되었을 것이다.

객체를 동적으로 생성할때 한가지 주의할 점은 '배열로 생성한 객체들은 반드시 배열로 삭제' 해야한다는 것


위의 main()함수에서 다음과 같이

int main()
{
	cout << "Begin" << endl;

	//new 연산자를 이용해 동적으로 객체를 생성한다.
	CTest *pData = new CTest[3];
	cout << "Test" << endl;

	//delete 연산자를 이용해 객체를 삭제한다.
	delete []pData;
	cout << "End" << endl;

	return 0;
}

객체를 배열을 이용해 동적으로 생성하였을 경우 마찬가지로 배열로 삭제해야 첫번째 요소 하나만 소멸하고 남은 요소들은
그대로 메모리에 남는 것을 방지 할 수 있다. 참고로 저렇게 수정하면 생성자 소멸자 다 3번씩 나옴


참조형식 멤버 초기화

클래스의 멤버 변수는 참조형식으로 선언할 수 있다. 그런데 참조자는 반드시 '선언과 동시에 초기화 해야한다'
그러므로 반드시 '생성자 초기화 목록'을 이용하여 초기화 하여야 한다.

#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CRefTest
{
public:
	//참조형 멤버는 반드시 생성자 초기화 목록을 이용해 초기화 한다.
	CRefTest(int &rParam) : m_nData(rParam) {};
	int GetData(void) { return m_nData; };

private:
	//참조형 멤버는 객체가 생성될때 반드시 초기화 하여야 한다.
	int &m_nData;
};

//사용자의 코드
int main()
{
	int a = 10;
	CRefTest t(a);

	cout << t.GetData() << endl;

	//참조 원본인 a값이 수정되었다.
	a = 20;
	cout << t.GetData() << endl;

	return 0;
}

위의 코드와 같이 생성자가 생성될때 초기화 목록을 이용하여 초기화 한다
만약 초기화 목록을 사용하지 않고 

CRefTest(int &rParam) { m_nData = rParam }  // 생성자 초기화 목록을 사용하지 않은 경우

와 같이 초기화 하려는 경우
=은 단순 대입 연산자 이므로 위 코드는 선언 및 정의가 아니고 이미 선언된 인스턴스를 이용하여 연산하는 것에 불과하다
이런 경우는 컴파일 에러가 나기 때문에 빌드 자체가 불가능하다.

그러나 다음 코드 처럼 작성 할 경우 힘든 상황이 나오게 된다

CRefTest(int rParam) : m_nData(rParam) { }; // 생성자의 매개변수를 참조자 형식으로 받지 않은 경우

정확히는 알 수 없으나 11932738 같은 쓰레기 값이 출력되게 되는데 이는 참조자가 가리키는 원본이 이미 삭제되었기
때문이다. '함수의 매개변수는 함수 내부의 자동변수'와 같으므로 함수가 반환 될 때 매개변수는 소멸되게 된다.
따라서 m_nData(rParam) 라는 코드는 결국 사라질 대상에 대한 참조자가 초기화 되는 결과가 초래된다.

생성자 다중 정의

생성자도 함수이므로 당연히 다중 정의 가능.
#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CMyData
{
public:
	//디폴트 생성자 X
	//매개변수가 int 하나인 생성자 함수 선언 및 정의
	CMyData(int nParam) : m_nData(nParam) {};

	//매개변수가 int 자료형 두개인 생성자 함수 선언 및 정의
	CMyData(int x, int y) : m_nData(x + y) {};

	int GetData(void) { return m_nData; }

private:
	int m_nData;
};

//사용자의 코드
int main()
{
	CMyData a(10);
	CMyData b(3, 4);

	cout << a.GetData() << endl;
	cout << b.GetData() << endl;

	return 0;
}

사용자가 같은 이름을 가진 다른 객체를 생성하더라도 매개 변수에 따라 다른 생성자가 호출되는 것을 알수 있음
이러한 다중 정의의 경우 사용자는 편하겠지만 제작자는 여러번 같은 코드를 기술해야 되서 귀찮음
그리고 이건 때때로 머가리 때리는 버그를 만드는 경우로 이어질 수도 있따. 그래서 과거엔 별도의 초기화 멤버 함수를
만들고 이를 호출하는 형태를 취했지만....

C++ 11에서는 그럴 필요가 없다! '생성자 위임'이 지원되기 때문
이 생성자 위임을 사용하면 생성자 초기화 목록에서 다른 생성자를 추가로 부를수 있다.


#include "stdafx.h"
#include <iostream>
using namespace std;

//제작자의 코드
class CMyPoint
{
public:
	CMyPoint(int x)
	{
		cout << "CMyPoint(int)" << endl;
		//x값이 100이 넘는지 검사하고 넘으면 100으로 맞춘다
		if (x > 100)
			x = 100;

		m_x = 100;
	}

	CMyPoint(int x, int y)
		//x값을 검사하는 코드는 이미 존재하므로 재사용 한다
		: CMyPoint(x)
	{
			cout << "CMyPoin(int, int)" << endl;
			//y값이 200을 넘는지 검사하고 넘으면 200으로 고정

			if (y > 200)
				y = 200;

			m_y = 200;

	}

	void Print()
	{
		cout << "X : " << m_x << endl;
		cout << "Y : " << m_y << endl;
	}

private:
	int m_x = 0, m_y = 0;
};

//사용자의 코드
int main()
{
	//매개변수가 하나인 생성자만 호출한다.
	CMyPoint ptBegin(110);
	ptBegin.Print();

	//이번엔 두개짜리
	CMyPoint ptEnd(50, 250);
	ptEnd.Print();

	return 0;
}

위의 코드에서 CMyPoint(int) 생성자는 내부에서 매개변수로 전달된 값을 강제로 100으로 조정하는 코드이다
복붙해서 CMyPoint(int, int)에 붙여넣는건 어렵지 않지만 유지보수 측면에서 매우 구리다.
그래서 초기화 목록에서 CMyPoint(int) 생성자를 추가로 호출될 수 있도록 위임 했다. 이렇게 함으로써 같은 일을 하는 코드가
여러번 반복되어 나타날 필요가 없어졌다.

*참고* 매개변수가 한개 뿐인 생성자를 변환 생성자라고 부르기도 한다. 나중에 중요하니까 참고할 것

명시적 디폴트 생성자

클래스에서도 멤버 함수의 선언과 정의를 분리할 수 있다.

그런데 default 예약어를 사용하면 별도로 정의 하지 않아도 선언과 정의를 한번에 끝낼 수 있다.


#include "stdafx.h"
#include <iostream>
using namespace std;

class CTest
{
public:
	//디폴트 생성자 선언
	CTest(void);
	int m_nData = 5;
};

//클래스 외부에서 디폴트 생성자 정의
CTest::CTest(void){}

int main()
{
	CTest a;
	cout << a.m_nData << endl;

	return 0;
}

위의 코드는 생성자의 선언과 정의를 클래스에서 분리시켜버린 모습이다.  하지만 이런경우 클래스 선언 내부에 생성자의
정의까지 포함되는 것이므로 선언과 정의를 명백히 분리해야 할 경우 이런 식으로 코드를 작성 할 수 없음
따라서 다음과 같이 선언 하면 별도로 정의를 기술하지 않고도 선언과 정의가 완벽하게 분리됨

Class CTest
{
public:
	//디폴트 생성자 선언 및 정의!
	CTest(void) = default;
	int m_nData = 5;
};
지금은 이러한 방법이 있다는 것만 알아둘것 나중에 템플릿 이용 프로그래밍 가면 절실히 필요할것이다 깔깔깔

또 하나 알아둘 것. 생성자 다중 정의를 통해 새로운 생성자를 기술하고 디폴트 생성자를 기술하지 않으면
디폴트 생성자는 사라진것이라고 볼 수 있음. 그런데 그게 대놓고 '나 없어짐 ㅋ' 하는게 아니라 혼란스러울 수 있는데
그럴땐 다음과 같이 코드를 작성하면 좋다

CTest(void) = delete;

만일 이것 마냥 디폴트 생성자를 삭제하고 CTest a; 같은 디폴트 생성자를 부르는 코드를 실행하면 에러남 그럼 쉽게 알수 잇음ㅋ

C++은 함수를 추가하는것만 있지 삭제하는 방법은 없어서 골치아팠는데 c++ 11에서 함수 삭제 기능이 추가되서 넘 조음
지금은 그냥 default, delete 예약어가 다른 형태로 사용되는 경우가 있다는것만 알아둘것


3.4 메서드

메서드의 사전적 의미는 '방법' 이다. 하지만 클래스 멤버 함수를 메서드라고도 한다 ㅋ
또한 멤버 함수는 상황에 따라 인터페이스 함수라고 부를 수도 있음ㅋ

다음은 멤버 함수의 원형이다.

static 반환자료형 클래스이름::함수이름(매개변수) const;

static과 const 예약어는 생략 가능 참고로 static이면 '정적 멤버 함수' 라고 하고, const면 '상수형' 혹은 '상수화된' 멤버 함수라고
부른다. 이제부턴 멤버 함수 대신 메서드, 인터페이스 함수라고 구분해서 말할꺼임

종류		일반			상수화			정적			가상

관련예약어	-			const			Static			virtual
this포인터접근	가능			가능			불가능			가능
일반멤버읽기	가능			가능			가능(제한적)		가능
일반멤버쓰기	가능			불가능			가능(제한적)		가능
정적멤버읽기	가능			가능			가능			가능
정적멤버쓰기	가능			불가능			가능			가능
특징	가장보편적메서드		멤버쓰기 방지가 목적	C의 전역함수와 유사	상속관계에서 의미가 큼

위는 메서드의 종류와 특징임 아직 안배운 가상 함수도 나옴

3.4.1 this 포인터(어려운듯)

this 포인터란? 작성중인 클래스의 실제 인스턴스에 대한 주소를 가리키는 포인터
핸드폰의 시리얼 번호같은것이다. 

#include "stdafx.h"
#include <iostream>
using namespace std;

class CMyData
{
public:
	CMyData(int nParam) : m_nData(nParam) {};
	void PrintData()
	{
		//m_nData값을 출력한다.
		cout << m_nData << endl;
		
		//CMyData 클래스의 멤버인 m_nData의 값을 출력한다.
		cout << CMyData::m_nData << endl;

		//메서드를 호출한 인스턴스의 m_nData값을 출력한다.

		cout << this->m_nData << endl;

		//메서드를 호출한 인스턴스의 CMyData 클래스 멤버 m_nData를 출력한다.

		cout << this->CMyData::m_nData << endl;
	}

private:
	int m_nData;
};

int main()
{
	CMyData a(5), b(10);
	a.PrintData();
	b.PrintData(); // &a와 &b는 보이지 않지만 실제로는 전달된다.

	return 0;
}

위의 코드는 실제로 this 포인터를 이용하여 m_nData의 값을 출력하는 코드인데 평범하게 m_nData를 사용하여 출력할 수도
있지만, 정확하게 작성해야 할 필요가 있을 경우에는 cout << this->CMyData::m_nData << endl; 처럼 범위 지정 연산자를
사용하여 소속을 정확히 명시할 수 있고 this 포인터를 통해 접근 할 수 있도록 사용하는 것이 좋다.
단순히 m_nData 라고만 써도 실제로 컴파일 될때는 this->m_nData로 컴파일 된다.

#include "stdafx.h"
#include <iostream>
using namespace std;

class CMyData
{
public:
	CMyData(int nParam) : m_nData(nParam) {};
	***void PrintData(CMyData *pData)
	{
		***CMyData *this = pData;
		//m_nData값을 출력한다.
		cout << m_nData << endl;
		
		//CMyData 클래스의 멤버인 m_nData의 값을 출력한다.
		cout << CMyData::m_nData << endl;

		//메서드를 호출한 인스턴스의 m_nData값을 출력한다.

		cout << this->m_nData << endl;

		//메서드를 호출한 인스턴스의 CMyData 클래스 멤버 m_nData를 출력한다.

		cout << this->CMyData::m_nData << endl;
	}

private:
	int m_nData;
};

int main()
{
	CMyData a(5), b(10);
	***a.PrintData(&a);
	***b.PrintData(&b); // &a와 &b는 보이지 않지만 실제로는 전달된다.

	return 0;
}

즉 C 스타일 코드로 표현하자면 위의 별 표시된 코드들 처럼 사용되지만 실제로는 저렇게 쓰면 문법 오류나서 컴파일 에러걸림
만일 호출자 함수에서 인스턴스의 주소를 넘겨줄 수 있도록 허용하면 이런 문제있는 코드를 작성 할 수 있다

a.PrintData(&b);
b.PrintData(&a);

원래는 위에 &a 아래에 &b를 쓰려던 거겠지만 이런 실수를 아예 원천적으로 차단하기 위해 this 포인터가 탄생한것.

!@#!@$#@$			실스으으으으으으읍 과제 1번!!			@##@$#@%

풀어보자...!



















